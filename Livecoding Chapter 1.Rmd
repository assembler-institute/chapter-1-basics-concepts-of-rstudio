---
title: "Livecoding Chapter 1"
output:
  html_document: default
  html_notebook: default
  pdf_document: default
---

## Data processing and file loading in R.


# Operations on vectors and booleans

Generate a vector, identify the type of object and find out its length:

```{r}

x<-c(1:10)
x

class(x)

length(x)

```

Generate jump interval vectors, repeated value vectors, character vectors.

```{r}

seq(1,9,by=2)
seq(1,9,length=6) 

rep(3,10)

x<-c("a","e","i","o","u")
x
class(x)
```

Sort vectors

```{r}
a <- c(2,4,6,3,1,5)
b <- sort(a)
c <- sort(a,decreasing = TRUE)
a
b
c
```

Booleans (**True: TRUE or T and False: FALSE or F**indicate whether a condition is met at each position of a vector. The symbol `!` is a negation.

```{r}

c(TRUE, FALSE)
c(F, T)
!c(F,T)
c(F,T) == !c(T,F)
x<-c(1,-1,2,-2)
x>0

```


Apply filters on vectors.

```{r}
x
x[x>0]
x[1:3] # from position 1 to 3
x[-(1:3)] # complement of position [1, 3], in this case position {4}
x[c(T,F)] #odd coordinates, i.e. odd positions
x[c(F,T)] #even coordinates, even positions
```

Reassigning values according to position, knowing if a position is a `NaN` (a missing or unknown value), knowing which positions have missing values, selecting those positions that do not have a missing value

```{r}
x[5] <- NaN # add a NaN value in position 5
x
!is.na(x) # returns boolean vector detecting non-missing values
is.na(x) # returns boolean vector detecting missing values

x[!is.na(x)] #eliminates the NaN from the vector (only non-missing values are selected)
which(is.nan(x)) # returns position of missing values

```


# Type of data
### Factors

They are "vectors" that have categorical components.

```{r}

prov<-c("lu","co","lu","po","co","or","co","lu","lu","po","co","or","co","co","lu","po")
prov
class(prov) #this is now a vector composed of characters

```

We transform it into a factor, in the transformation the **Levels** are established, which are the different categories contained by the factor

```{r}

provf<-factor(prov) #convert to factor
provf
class(provf)
levels(provf) 
```

Show the indices where the value "lu" is found

```{r}

which(provf=="lu") 

```

We modify the type of the elements of a factor

```{r}

as.character(provf) # transform from factor to strings

q <- factor(c('0.8','2.4','3.1')) # define a factor from a vector
q
q1 <- as.double(q) # transform factor to double
class(q1)
q # attention, note that the original q variable is not modified

```
We install the *plyr* library and see its application

```{r}

# install.packages("plyr")
library(plyr) #load library
help(plyr) #gives info about the library
?plyr

```

We apply various functions of the installed library.

```{r}

table(provf)

```

### Arrays and Matrices

They are arrays that contain a single type of element. Support the usual **linear algebra operations**

```{r}
A <- array(1:20,dim=c(4,5)) # generate 4 row x 5 column matrix
A

class(A)

A[1,3] #extracts position (1,3)
A[,1] #extracts column 1
A[3,] #extracts row 3
A[1:3, 2:5] #selects a submatrix with rows between 1 and 3 and columns between 2 and 5

nrow(A) # number of rows
ncol(A) # number of columns
dim(A) #dimension
t(A) #matrix tranpose

A*A #position-to-position product
A^3 #power position to position

sin(A) #sine of the matrix 
B<- A[1:2,1:2] #define a new B matrix 
B
A

solve(B) #matrix inverse

B%*%solve(B) #matrix product
```
### DataFrames

Dataframes are tables in which each column represents a reading of a different nature. For example a column can be height, another hair color, etc...

We see before the dataframes variable listing and auxiliary deletion operations

```{r}

ls() #list of all created variables
rm("A") #remove variable A
ls()
rm(list=ls()) #remove all elements in the memory
ls()

```

Next we see the dataframes

```{r}

name <- c("Luis","Carmen", "Pedro"); edad <- c(15,10,30); altura <- c(1.65,1.85, 1.45)
M <- data.frame(name,edad, altura)
M

```

Main attributes

```{r}

attributes(M) #names of the columns and rows as well as the data type
dim(M) #dimension
colnames(M) #columns names
rownames(M) #row names
nrow(M) #number of rows
ncol(M) #number of columns

```

To get a quick summary of the dataframe we use str, this command indicates the type of each column and its first values.
With the head command we can see the header (first rows) of the dataframe, and with tail() the last rows of it.

```{r}

str(M)

``` 
```{r}
head(M)

tail(M)
```

Let's see how subsets of the dataframe are taken, how values can be modified and other essential operations.

```{r}
M$name #columns selection
M$edad
M$altura


M[1,] #selects first row
M[1,1:2] #select from the first row the positions of the first and second columns
M[,-1] #the entire dataframe except the last column
M['altura'] #column high
M$altura <- c(1.9,2, 50) #we modify the values of the height column
M

M$peso <- 4*M$edad +2*cos(M$altura) #we apply column transformations by creating a new variable, weight
M

subset(M,select=c(name,edad)) #other ways to take subsets
subset(M,subset=c(name=="Luis")) # we select those rows in which name == "Luis"
M[M$name=="Luis" & M$edad<20,] # select rows using filters
```

### Lists

Lists are heterogeneous "vectors", this means that each element can be of a different type.
They have storage names by which the values are accessed. It resembles Python dictionaries in that it is a set of key-value pairs.

```{r}
Lst <- list(name="Fred", wife="Mary", no.children=3, child.ages=c(4,7,9))
Lst

Lst$name
Lst$wife
Lst$no.children
Lst$child.ages

length(Lst) #lenght
attributes(Lst) #attributes
names(Lst) #keys to access items


Lst[[1]] #can also be accessed by position
Lst[[4]]
Lst[[4]][3]
```

Items in a list can be **attached** as environment variables for easier access using the `attach` command.
In this operation, care must be taken that the names do not coincide with a global variable, otherwise it will not be available, in this case it happens for `name`

```{r}
attach(Lst) #we bind the variable Lst so that its components are global variables
wife
no.children
child.ages


```

# Description and grouping operations on tables

# grouping operations

`apply` and `sapply` apply a grouping function by row or column

```{r}

A <- array(1:20,dim=c(4,5))
A

#Mat <- matrix(1:20,4,5) is the same as what was created in A, same class array matrix


help(apply)
apply(A,1,sum) # the value 1 indicates that the function is applied by rows
apply(A,2,max) # the value 2 indicates that the function is applied by columns
apply(A,1,is.vector) #boolean T/F if rows are vectors

```



```{r}

data(cars) #load dataset cars (predefined in Rstudio)

help(cars) #dataset description
cars
dim(cars) #cars dimension
summary(cars) #cars summary

# sapply applies a function to each element of x

help(sapply) #sapply help
sapply(cars,class) #returns the class of each column
sapply(cars,log) #returns the logarithm of each column


```

`tapply` also does append but over lists

```{r}

help(tapply)
hijos<-c(1,3,2,2,3,5,3,2,1,2,3,1,2,4,1,0)
prov<-c("lu","co","lu","po","co","or","co","lu","lu","po","co","or","co","co","lu","po")
provf<-factor(prov)
tapply(hijos,provf,mean) #makes the average by categories relating the children and provf lists

```

## Loading a dataset and basic description

We use the `read.csv` and `write.csv` functions to load and read *.csv*.

```{r}
data() #view available data
data("USArrests") #load a dataset from the R repository
USArrests

getwd() #directory in which I am

#setwd("C:\Users\Paloma\Desktop\Assembler Institute of Technology") to change directory

#especially for reading files or exporting.

write.csv(USArrests,"USArrests_2.csv") #writes dataset in .csv
read.csv("USArrests.csv") #read dataset

# If it is in another directory that is not the one we have predefined, we can mark the path of our local:

read.csv("C:/Users/Paloma/Desktop/Assembler Institute of Technology/USArrests.csv")

#The variable x happens to be what the rows are called
dat <- read.csv("USArrests.csv",row.names = 'X')
dat

str(dat)

```



## `dplyr` applications

It is a library focused on data grouping and selection.

The core operations we can perform:

1. select() select columns
2. filter() select rows
3. arrange() sort the data
4. mutate() transform a column
5. summarise() add the previously grouped data
6. group_by() group the data by a key, usually one or more columns
7. left_join() join/merge dataframes

Let's see with examples what it can do:

First, we install and load the library.

```{r}
#install.packages("dplyr")
library(dplyr)
```

We load the data and look at the first few rows.

```{r}

data("airquality")
head(airquality)

```
**select** We select specific variables of our data.frame

```{r}

select(airquality, Ozone, Solar.R, Wind) # selection of Ozone, Solar.R and Wind variables

```

**filter** We filter the records of our data.frame according to the values that certain variables take.


```{r}

filter(airquality, Temp > 70) # we filter records with temperature greater than 70
filter(airquality, Temp > 80 & Month > 5) # the same but we add the month condition greater than 5

```

**arrange** We order the records based on one or several variables

```{r}
arrange(airquality, desc(Month), Day) # arrange by month (descending) and by day (ascending)
```

**mutate** We modify the values of a variable.

In this case we create a new variable from another: we pass the temperature variable, which was in degrees Fahrenheit, to degrees Celsius.

```{r}

mutate(airquality, TempInC = (Temp - 32) * 5 / 9) # We create the variable TempInC from the variable Temp

airquality$TempInC <- ((airquality$Temp - 32) * 5 / 9) # in this way you also create it but not with the dplyr library, and incorporate it into the dataframe

ar

airquality
```

**summarise** Computes statistical characteristics on variables.

```{r}

summarise(airquality, mean(Temp, na.rm = TRUE)) # computes the mean temperature ignoring missing values

```



**group_by** On many occasions we will seek to obtain aggregated data according to the values that a certain variable takes.

The aggregated data will be the result of carrying out operations on the rest of the operations.
For example, we can group by the Month variable and take the average temperature for each month using the summarise function
That is, the objective is to know the average temperature per month.

```{r}
summarise(group_by(airquality, Month), mean(Temp, na.rm = TRUE)) # groups by month and calculates the average temperature in that month
```

**left_join** Allows us to link multiple tables horizontally (i.e. at the record level).

Suppose we have a "master" table where we get the ID of a person next to their name and we also have a "colors" table with the person's ID and their favorite color.

If we cross the table "master" with the table "colors" by the variable ID, we will obtain a table with the ID, the name and the favorite color of the person.

We create the two data.frame:

```{r}
IDs <- c("0001", "0002", "0003")
nombres <- c("Álvaro", "Miriam", "Laura")
colores_fav <- c("Azul marino", "Lila", "Azul turquesa")

master <- data.frame(IDs, nombres)
colores <- data.frame(IDs, colores_fav)

master
colores
```
Now, we will perform a join of the master table with the colors table:

```{r}
left_join(master, colores, by="IDs")

```
**More Features** The dplyr library has many features. A very commonly used function is **count**.


```{r}
count(airquality, Month) #counts the number of records for each value of the Month variable
```

With the operator **pipe** `%>%` the above transformations can be done in sequence, this is a very comfortable syntax for working on tables

```{r}
airquality %>% 
    filter(Month != 5) %>% # filter by months other than 5
    group_by(Month) %>% # group by month
    summarise(mean(Temp, na.rm = TRUE)) # calculates the average
```


# Functions and loops

We create a function that adds two values x and y

```{r}
func <- function(x,y){
  #operaciones
  #respuesta
  return(x+y)
}

func(3,5)
func(c(1,3), c(5,10)) # function applied to vectors
```

The following loop paints the value of the iterator (the i) over the range it traverses

```{r}
for (i in 1:5){
  print(i)
}
```

We define a branch where "is male" is returned for input "H" and "is female" otherwise

```{r}

x<-"M"

if (x=="H"){
  print("Es hombre")
}else{print("Es mujer")}

```

We create a vector and modify it based on the position giving it values 0 and 1

```{r}

x <- c(1:20) # vector from 1 to 20
x
y <- numeric(length(x)) # 20 zeros vector
y
class(y)

y2 <- rep(0,20) #another way to create a 20 zeros vector
#class(y2)
y2
y
for (i in 1:length(x)) if (x[i] == 3) y[i] <- 0 else y[i] <- 1
y

```

### Activity for the student to do
### -----------------
1. Write a function that takes a vector and counts the number of positive elements
2. Write a function that, given a natural number, calculates its factorial
3. Make a loop that prints which city has the maximum of each column and how much it is worth
in the USArrests dataset (it's in data(USArrests))

### SOLUTION:
```{r}

# 1. Write a function that takes a vector and counts the number of positive elements

cuentapositivos <- function(x){
  return(sum(x>0))

}

cuentapositivos(c(-3,2,10,-7,9,90))

# 2. Write a function that, given a natural number, calculates its factorial
# The factorial of a number is the result of multiplying said number by all the natural numbers that precede it, excluding zero: P.e: 4! = 4x3x2x1

fact <- function(n){
  return(prod(1:n))
}

fact(7)

# 3. Make a loop that prints which city has the maximum of each column and how much it is worth in the USArrests dataset
#(is in data(USArrests))

data("USArrests")
USArrests

for (i in colnames(USArrests)){ # i va tomando los diferentes nombres de las columnas
  
  print(c(i,rownames(USArrests)[which.max(USArrests[,i])])) # imprime nombre de la variable y ciudad con el valor máximo de dicha variable ( no imprime el valor maximo,p.ejemplo: el valor max de la variable murder está en la ciudad de Georgia)
  
  print(max(USArrests[i])) # imprime el valor máximo de la variable en esa ciudad 
}

```

